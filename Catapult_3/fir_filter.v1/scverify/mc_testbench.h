// ----------------------------------------------------------------------------
// SystemC Testbench Header
//
//    HLS version: 10.3a/798110 Production Release
//       HLS date: Tue Dec  4 22:20:19 PST 2018
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 8.0a
//
//   Generated by: jd4691@newnano.poly.edu
// Generated date: Wed Jun 23 00:11:18 EDT 2021
//
// ----------------------------------------------------------------------------
#ifdef CCS_SCVERIFY

// 
// -------------------------------------
// testbench
// User supplied testbench
// -------------------------------------
// 
#ifndef INCLUDED_TESTBENCH_H
#define INCLUDED_TESTBENCH_H

extern void mc_testbench_i_sample_skip(bool v);
extern void mc_testbench_b_skip(bool v);
extern void mc_testbench_y_skip(bool v);

#ifndef SC_USE_STD_STRING
#define SC_USE_STD_STRING
#endif

#include "/opt/mentorgraphics/Catapult_10.3a/Mgc_home/shared/training/ondemand/module4/src/fir_filter.h"
#include <systemc.h>
#include <tlm.h>
#include <ac_fixed.h>
#include <mc_container_types.h>
#include <mc_typeconv.h>
#include <mc_transactors.h>
#include <mc_comparator.h>
#include <mc_end_of_testbench.h>
#include <vector>


class testbench : public sc_module
{
public:
   // Interface Ports
   sc_in< bool > clk;
   sc_port< tlm::tlm_fifo_put_if< ac_fixed<3, 1, true, AC_TRN, AC_WRAP > > > ccs_i_sample;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_i_sample;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<ac_fixed<10, -2, true, AC_TRN, AC_WRAP >,127> > > ccs_b;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_b;
   sc_port< tlm::tlm_fifo_get_if< ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > > > ccs_y;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_y;
   sc_in< bool > design_is_idle;
   sc_out< sc_logic > enable_stalls;
   sc_in< unsigned short > stall_coverage;
   
   // Data objects
   bool testbench_ended;
   int main_exit_code;
   bool atleast_one_active_input;
   sc_time last_event_time;
   sc_time last_event_time2;
   sc_signal< bool >                          cpp_testbench_active;
   sc_event testbench_end_event;
   int argc;
   const char* const *argv;
   bool _checked_results;
   bool _failed;
   static testbench* that;
   int main();
   static bool enable_idle_sync_mode;
   static unsigned short idle_sync_stable_cycles;
   static bool i_sample_ignore;
   static bool i_sample_skip;
   static bool i_sample_skip_quiet;
   static bool i_sample_skip_once;
   static bool i_sample_skip_noerr;
   static int i_sample_array_comp_first;
   static int i_sample_array_comp_last;
   bool _capture_i_sample;
   static mc_wait_ctrl i_sample_wait_ctrl;
   int i_sample_capture_count;
   int i_sample_iteration_count;
   static bool b_ignore;
   static bool b_skip;
   static bool b_skip_quiet;
   static bool b_skip_once;
   static bool b_skip_noerr;
   static int b_array_comp_first;
   static int b_array_comp_last;
   bool _capture_b;
   static mc_wait_ctrl b_wait_ctrl;
   int b_capture_count;
   int b_iteration_count;
   static bool y_ignore;
   static bool y_skip;
   static bool y_skip_quiet;
   static bool y_skip_once;
   static bool y_skip_noerr;
   static int y_array_comp_first;
   static int y_array_comp_last;
   static bool y_use_mask;
   static ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > y_output_mask;
   tlm::tlm_fifo< mc_golden_info< ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM >, ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > > > y_golden;
   bool _capture_y;
   static mc_wait_ctrl y_wait_ctrl;
   int y_capture_count;
   int y_iteration_count;
   int wait_cnt;
   
   // Named Objects
   
   // Module instance pointers
   mc_comparator< ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > , ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > > *y_comp;
   
   // Declare processes (SC_METHOD and SC_THREAD)
   void wait_for_end();
   void run();
   
   // Constructor
   SC_HAS_PROCESS(testbench);
   testbench(
      const sc_module_name& name
   )
      : clk("clk")
      , ccs_i_sample("ccs_i_sample")
      , ccs_wait_ctrl_i_sample("ccs_wait_ctrl_i_sample")
      , ccs_b("ccs_b")
      , ccs_wait_ctrl_b("ccs_wait_ctrl_b")
      , ccs_y("ccs_y")
      , ccs_wait_ctrl_y("ccs_wait_ctrl_y")
      , design_is_idle("design_is_idle")
      , enable_stalls("enable_stalls")
      , stall_coverage("stall_coverage")
      , cpp_testbench_active("cpp_testbench_active")
      , y_golden("y_golden",-1)
   {
      // Instantiate other modules
      y_comp = new mc_comparator< ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > , ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > > (
         "y_comp",
         "y",
         0,
         0,
         1
      );
      y_comp->data_in(ccs_y);
      y_comp->data_golden(y_golden);
      
      
      // Register processes
      SC_METHOD(wait_for_end);
      sensitive << clk.pos() << testbench_end_event;
      SC_THREAD(run);
      // Other constructor statements
      set_stack_size(64000000);
      argc = sc_argc();
      argv = sc_argv();
      _checked_results = false;
      that = this;
      testbench_ended = false;
      main_exit_code = 0;
      atleast_one_active_input = true;
      _failed = false;
      _capture_i_sample = true;
      _capture_b = true;
      _capture_y = true;
      wait_cnt = 0;
   }
   
   ~testbench()
   {
      delete y_comp;
      y_comp = 0;
   }
   
   // C++ class functions
   public:
      static void wait_for_idle_sync() ;
   public:
      static void set_enable_stalls(bool flag) ;
   public:
      void capture_i_sample(ac_fixed<3, 1, true, AC_TRN, AC_WRAP > i_sample) ;
   public:
      void capture_b( ac_fixed<10, -2, true, AC_TRN, AC_WRAP > b[127]) ;
   public:
      void capture_y( ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > &y) ;
   protected:
      void wait_on_input_required() ;
   public:
      static void capture_IN(ac_fixed<3, 1, true, AC_TRN, AC_WRAP > i_sample,  ac_fixed<10, -2, true, AC_TRN, AC_WRAP > b[127],  ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > &y) ;
   public:
      static void capture_OUT(ac_fixed<3, 1, true, AC_TRN, AC_WRAP > i_sample,  ac_fixed<10, -2, true, AC_TRN, AC_WRAP > b[127],  ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > &y) ;
   public:
      static void exec_fir_filter(ac_fixed<3, 1, true, AC_TRN, AC_WRAP > i_sample,  ac_fixed<10, -2, true, AC_TRN, AC_WRAP > b[127],  ac_fixed<9, 1, true, AC_RND, AC_SAT_SYM > &y) ;
   protected:
      void start_of_simulation() ;
   protected:
      void end_of_simulation() ;
   public:
      void check_results() ;
   public:
      bool failed() ;
   public:
      void set_failed(bool fail) ;
};
#endif
#endif
