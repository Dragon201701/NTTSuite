// ----------------------------------------------------------------------------
// User Testbench Interface Header
//
//    HLS version: 10.5c/896140 Production Release
//       HLS date: Sun Sep  6 22:45:38 PDT 2020
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4.1
//
//   Generated by: jd4691@newnano.poly.edu
// Generated date: Mon Sep 13 23:15:00 EDT 2021
//
// ----------------------------------------------------------------------------

#ifndef CCS_TESTBENCH_H
#define CCS_TESTBENCH_H
#include <ac_int.h>
#include "mc_wait_ctrl.h"
#include <string.h>
#include <iostream>

class testbench
{
   public:
   int argc;
   char** argv;
   int main(); //CCS_MAIN
   static bool enable_idle_sync_mode;
   static unsigned short idle_sync_stable_cycles;
   static void set_enable_stalls(bool flag);
   static void reset_request();
   static bool x_ignore;
   static bool x_skip;
   static bool x_skip_quiet;
   static bool x_skip_once;
   static bool x_skip_noerr;
   static int  x_array_comp_first;
   static int  x_array_comp_last;
   static mc_wait_ctrl x_IN_wait_ctrl;
   static bool x_use_mask;
   static ac_int<32, false > x_output_mask;
   static mc_wait_ctrl x_wait_ctrl;
   static bool m_ignore;
   static bool m_skip;
   static bool m_skip_quiet;
   static bool m_skip_once;
   static bool m_skip_noerr;
   static int  m_array_comp_first;
   static int  m_array_comp_last;
   static mc_wait_ctrl m_wait_ctrl;
   static bool twiddle_ignore;
   static bool twiddle_skip;
   static bool twiddle_skip_quiet;
   static bool twiddle_skip_once;
   static bool twiddle_skip_noerr;
   static int  twiddle_array_comp_first;
   static int  twiddle_array_comp_last;
   static mc_wait_ctrl twiddle_wait_ctrl;
   static bool twiddle_h_ignore;
   static bool twiddle_h_skip;
   static bool twiddle_h_skip_quiet;
   static bool twiddle_h_skip_once;
   static bool twiddle_h_skip_noerr;
   static int  twiddle_h_array_comp_first;
   static int  twiddle_h_array_comp_last;
   static mc_wait_ctrl twiddle_h_wait_ctrl;
   static bool revArr_ignore;
   static bool revArr_skip;
   static bool revArr_skip_quiet;
   static bool revArr_skip_once;
   static bool revArr_skip_noerr;
   static int  revArr_array_comp_first;
   static int  revArr_array_comp_last;
   static mc_wait_ctrl revArr_wait_ctrl;
   static bool tw_ignore;
   static bool tw_skip;
   static bool tw_skip_quiet;
   static bool tw_skip_once;
   static bool tw_skip_noerr;
   static int  tw_array_comp_first;
   static int  tw_array_comp_last;
   static mc_wait_ctrl tw_wait_ctrl;
   static bool tw_h_ignore;
   static bool tw_h_skip;
   static bool tw_h_skip_quiet;
   static bool tw_h_skip_once;
   static bool tw_h_skip_noerr;
   static int  tw_h_array_comp_first;
   static int  tw_h_array_comp_last;
   static mc_wait_ctrl tw_h_wait_ctrl;
   #ifndef CCS_SCVERIFY_USE_CCS_BLOCK
   static void exec_hybrid( ac_int<32, false > x[1024], ac_int<32, false > m,  ac_int<32, false > twiddle[32],  ac_int<32, false > twiddle_h[32],  ac_int<20, true > revArr[32],  ac_int<32, false > tw[1024],  ac_int<32, false > tw_h[1024]);
   #endif
   explicit testbench(int _argc, const char* const *_argv)
      :argc(_argc), argv(const_cast<char**>(_argv))
   {
   }
   ~testbench()
   {
   }
   private:
   testbench() {}
};
extern void mc_testbench_reset_request();
extern void mc_testbench_x_skip(bool v);
extern void mc_testbench_m_skip(bool v);
extern void mc_testbench_twiddle_skip(bool v);
extern void mc_testbench_twiddle_h_skip(bool v);
extern void mc_testbench_revArr_skip(bool v);
extern void mc_testbench_tw_skip(bool v);
extern void mc_testbench_tw_h_skip(bool v);
#endif //CCS_TESTBENCH_H
