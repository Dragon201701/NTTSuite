// ----------------------------------------------------------------------------
// SystemC Testbench Body
//
//    HLS version: 10.5c/896140 Production Release
//       HLS date: Sun Sep  6 22:45:38 PDT 2020
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4.1
//
//   Generated by: yl7897@newnano.poly.edu
// Generated date: Thu Sep 16 12:34:55 EDT 2021
//
// ----------------------------------------------------------------------------
// 
// -------------------------------------
// mc_testbench
// SCVerify mc_testbench SC_MODULE
// -------------------------------------
// 
#include "mc_testbench.h"
#include <mc_testbench_util.h>
#include <mc_simulator_extensions.h>

mc_testbench* mc_testbench::that;
bool testbench::enable_idle_sync_mode;
unsigned short testbench::idle_sync_stable_cycles;
void testbench::set_enable_stalls(bool flag) { mc_testbench::set_enable_stalls(flag); }
void testbench::reset_request() { mc_testbench::that->reset_request(); }
void mc_testbench_reset_request() { mc_testbench::that->reset_request(); }
bool testbench::run_ignore;
void mc_testbench_run_skip(bool v) { testbench::run_skip = v; }
bool testbench::run_skip;
bool testbench::run_skip_quiet;
bool testbench::run_skip_once;
bool testbench::run_skip_noerr;
int  testbench::run_array_comp_first;
int  testbench::run_array_comp_last;
mc_wait_ctrl testbench::run_wait_ctrl;
bool testbench::vec_ignore;
void mc_testbench_vec_skip(bool v) { testbench::vec_skip = v; }
bool testbench::vec_skip;
bool testbench::vec_skip_quiet;
bool testbench::vec_skip_once;
bool testbench::vec_skip_noerr;
int  testbench::vec_array_comp_first;
int  testbench::vec_array_comp_last;
mc_wait_ctrl testbench::vec_IN_wait_ctrl;
bool testbench::vec_use_mask;
ac_int<32, false > testbench::vec_output_mask;
mc_wait_ctrl testbench::vec_wait_ctrl;
bool testbench::p_ignore;
void mc_testbench_p_skip(bool v) { testbench::p_skip = v; }
bool testbench::p_skip;
bool testbench::p_skip_quiet;
bool testbench::p_skip_once;
bool testbench::p_skip_noerr;
int  testbench::p_array_comp_first;
int  testbench::p_array_comp_last;
mc_wait_ctrl testbench::p_wait_ctrl;
bool testbench::r_ignore;
void mc_testbench_r_skip(bool v) { testbench::r_skip = v; }
bool testbench::r_skip;
bool testbench::r_skip_quiet;
bool testbench::r_skip_once;
bool testbench::r_skip_noerr;
int  testbench::r_array_comp_first;
int  testbench::r_array_comp_last;
mc_wait_ctrl testbench::r_wait_ctrl;
bool testbench::twiddle_ignore;
void mc_testbench_twiddle_skip(bool v) { testbench::twiddle_skip = v; }
bool testbench::twiddle_skip;
bool testbench::twiddle_skip_quiet;
bool testbench::twiddle_skip_once;
bool testbench::twiddle_skip_noerr;
int  testbench::twiddle_array_comp_first;
int  testbench::twiddle_array_comp_last;
mc_wait_ctrl testbench::twiddle_wait_ctrl;
bool testbench::twiddle_h_ignore;
void mc_testbench_twiddle_h_skip(bool v) { testbench::twiddle_h_skip = v; }
bool testbench::twiddle_h_skip;
bool testbench::twiddle_h_skip_quiet;
bool testbench::twiddle_h_skip_once;
bool testbench::twiddle_h_skip_noerr;
int  testbench::twiddle_h_array_comp_first;
int  testbench::twiddle_h_array_comp_last;
mc_wait_ctrl testbench::twiddle_h_wait_ctrl;
bool testbench::complete_ignore;
void mc_testbench_complete_skip(bool v) { testbench::complete_skip = v; }
bool testbench::complete_skip;
bool testbench::complete_skip_quiet;
bool testbench::complete_skip_once;
bool testbench::complete_skip_noerr;
int  testbench::complete_array_comp_first;
int  testbench::complete_array_comp_last;
bool testbench::complete_use_mask;
bool testbench::complete_output_mask;
mc_wait_ctrl testbench::complete_wait_ctrl;
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
extern "C++" void inPlaceNTT_DIT_precomp( ac_sync &run,  ac_int<32, false > vec[4096], ac_int<32, false > p, ac_int<32, false > r,  ac_int<32, false > twiddle[4096],  ac_int<32, false > twiddle_h[4096],  ac_sync &complete);
#endif
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
void testbench::exec_inPlaceNTT_DIT_precomp( ac_sync &run,  ac_int<32, false > vec[4096], ac_int<32, false > p, ac_int<32, false > r,  ac_int<32, false > twiddle[4096],  ac_int<32, false > twiddle_h[4096],  ac_sync &complete) {
   return mc_testbench::exec_inPlaceNTT_DIT_precomp(run, vec, p, r, twiddle, twiddle_h, complete);
}
#endif

// ============================================
// Function: wait_for_idle_sync
// --------------------------------------------

void mc_testbench::wait_for_idle_sync()
{
   if (testbench::enable_idle_sync_mode) {
      std::cout << "mc_testbench STOPPING   @ " << sc_time_stamp() << std::endl;
      that->cpp_testbench_active.write(false);
      while (that->design_is_idle.read())  that->wait(that->design_is_idle.value_changed_event());
      while (!that->design_is_idle.read()) that->wait(that->design_is_idle.value_changed_event());
      that->cpp_testbench_active.write(true);
      std::cout << "mc_testbench CONTINUING @ " << sc_time_stamp() << std::endl;
   } else {
      that->cpp_testbench_active.write(true);
   }
}
// ============================================
// Function: set_enable_stalls
// --------------------------------------------

void mc_testbench::set_enable_stalls(bool flag)
{
   if (flag) {
     std::cout << "Enabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_1);
   } else {
     std::cout << "Disabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_0);
   }
}
// ============================================
// Function: reset_request
// --------------------------------------------

void mc_testbench::reset_request()
{
   reset_request_event.notify(0,SC_NS);
}
// ============================================
// Function: capture_run
// --------------------------------------------

void mc_testbench::capture_run( ac_sync &run)
{
   static bool run_tmp;
   static int last_j_run_in = 0;
   if (run_iteration_count == wait_cnt)
      wait_on_input_required();
   if (_capture_run && !testbench::run_ignore)
   {
      if (!run_pointer_set) {
         run_pointer = &(run);
         run_pointer_set = true;
      } else if (run_pointer != &(run) && remaining_ccs_run == 0) {
         std::ostringstream msg; msg.str("");
         msg << "Interface run source switched to a difference object in testbench with "
             << remaining_ccs_run << " values remaining in input fifo. No data mismatch detected." <<" @ " << sc_time_stamp();
         SC_REPORT_INFO("User testbench", msg.str().c_str());
         run_pointer = &(run);
      } else if (run_pointer != &(run) && remaining_ccs_run > 0 && remaining_ccs_run != run.ac_channel<bool >::debug_size()) {
         std::ostringstream msg; msg.str("");
         msg << "Interface run source switched to a different object in testbench with "
             << remaining_ccs_run << " values remaining in input fifo. Simulation mismatch likely. Check golden vs DUT comparison values for errors." <<" @ " << sc_time_stamp();
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
         _channel_mismatch = true;
      }
      int cur_iter = run_capture_count;
      ++run_iteration_count;
      unsigned int chan_factor = 1;
      unsigned int ccs_scv_i,ccs_scv_j;
      ccs_scv_i = remaining_ccs_run;
      while (ccs_scv_i < run.ac_channel<bool >::debug_size()) {
         for (ccs_scv_j = last_j_run_in; ccs_scv_j < chan_factor; ccs_scv_j++,ccs_scv_i++) {
            if (ccs_scv_i < run.ac_channel<bool >::debug_size()) {
               run_tmp = run.ac_channel<bool >::chan[ccs_scv_i];
            } else {
               break;
            }
         }
         if (ccs_scv_j == chan_factor) {
            ccs_run->put(run_tmp);
            last_j_run_in = 0;
            run_capture_count += chan_factor;
         } else {
            last_j_run_in = ccs_scv_j;
         }
      }
      mc_testbench_util::process_wait_ctrl("run",testbench::run_wait_ctrl,ccs_wait_ctrl_run.operator->(),cur_iter,run_capture_count,1);
   }
   testbench::run_ignore = false;
}
// ============================================
// Function: capture_vec_IN
// --------------------------------------------

void mc_testbench::capture_vec_IN( ac_int<32, false > vec[4096])
{
   if (vec_IN_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_vec_IN && !testbench::vec_ignore)
   {
      int cur_iter = vec_IN_iteration_count;
      ++vec_IN_iteration_count;
      mgc_sysc_ver_array1D<ac_int<32, false >,4096> vec_IN_tmp;
      int vec_linear_idx = 0;
      for (int vec_idx_0 = 0; vec_idx_0 < 4096; ++vec_idx_0)
         vec_IN_tmp[vec_linear_idx++] = vec[vec_idx_0];
      ccs_vec_IN->put(vec_IN_tmp);
      ++vec_IN_capture_count;
      mc_testbench_util::process_wait_ctrl("vec_IN",testbench::vec_IN_wait_ctrl,ccs_wait_ctrl_vec_IN.operator->(),cur_iter,vec_IN_capture_count,0);
   }
   testbench::vec_ignore = false;
}
// ============================================
// Function: capture_vec
// --------------------------------------------

void mc_testbench::capture_vec( ac_int<32, false > vec[4096])
{
   if (_capture_vec)
   {
      int cur_iter = vec_iteration_count;
      ++vec_iteration_count;
      mc_golden_info< mgc_sysc_ver_array1D<ac_int<32, false >,4096>, MaskPacket<0, 32> > vec_tmp(testbench::vec_ignore, false, vec_iteration_count);
      vec_tmp._data.mc_testbench_process_array_bounds("vec",testbench::vec_array_comp_first,testbench::vec_array_comp_last,4095,0);
      // BEGIN: testbench output_mask control for field_name vec
      if ( testbench::vec_use_mask ) {
         sc_lv<32> tmp_mask_lv;
         type_to_vector(testbench::vec_output_mask, 32, tmp_mask_lv);
         vec_tmp._use_mask = true;
         vec_tmp._packet._mask = tmp_mask_lv;
      }
      // END: testbench output_mask control for field_name vec
      int vec_linear_idx = 0;
      for (int vec_idx_0 = 0; vec_idx_0 < 4096; ++vec_idx_0)
         vec_tmp._data[vec_linear_idx++] = vec[vec_idx_0];
      if (!testbench::vec_skip) {
         vec_golden.put(vec_tmp);
         ++vec_capture_count;
      } else {
         if (!testbench::vec_skip_quiet || !testbench::vec_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "testbench::vec_skip=true for iteration=" << vec_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            testbench::vec_skip_once = true;
         }
      }
      mc_testbench_util::process_wait_ctrl("vec",testbench::vec_wait_ctrl,ccs_wait_ctrl_vec.operator->(),cur_iter,vec_capture_count,0);
      testbench::vec_use_mask = false;
   }
   testbench::vec_ignore = false;
   testbench::vec_skip = false;
}
// ============================================
// Function: capture_p
// --------------------------------------------

void mc_testbench::capture_p(ac_int<32, false > p)
{
   if (p_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_p && !testbench::p_ignore)
   {
      int cur_iter = p_iteration_count;
      ++p_iteration_count;
      ccs_p->put(p); // THIS
      ++p_capture_count;
      mc_testbench_util::process_wait_ctrl("p",testbench::p_wait_ctrl,ccs_wait_ctrl_p.operator->(),cur_iter,p_capture_count,0);
   }
   testbench::p_ignore = false;
}
// ============================================
// Function: capture_r
// --------------------------------------------

void mc_testbench::capture_r(ac_int<32, false > r)
{
   if (r_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_r && !testbench::r_ignore)
   {
      int cur_iter = r_iteration_count;
      ++r_iteration_count;
      ccs_r->put(r); // THIS
      ++r_capture_count;
      mc_testbench_util::process_wait_ctrl("r",testbench::r_wait_ctrl,ccs_wait_ctrl_r.operator->(),cur_iter,r_capture_count,0);
   }
   testbench::r_ignore = false;
}
// ============================================
// Function: capture_twiddle
// --------------------------------------------

void mc_testbench::capture_twiddle( ac_int<32, false > twiddle[4096])
{
   if (twiddle_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_twiddle && !testbench::twiddle_ignore)
   {
      int cur_iter = twiddle_iteration_count;
      ++twiddle_iteration_count;
      mgc_sysc_ver_array1D<ac_int<32, false >,4096> twiddle_tmp;
      int twiddle_linear_idx = 0;
      for (int twiddle_idx_0 = 0; twiddle_idx_0 < 4096; ++twiddle_idx_0)
         twiddle_tmp[twiddle_linear_idx++] = twiddle[twiddle_idx_0];
      ccs_twiddle->put(twiddle_tmp);
      ++twiddle_capture_count;
      mc_testbench_util::process_wait_ctrl("twiddle",testbench::twiddle_wait_ctrl,ccs_wait_ctrl_twiddle.operator->(),cur_iter,twiddle_capture_count,0);
   }
   testbench::twiddle_ignore = false;
}
// ============================================
// Function: capture_twiddle_h
// --------------------------------------------

void mc_testbench::capture_twiddle_h( ac_int<32, false > twiddle_h[4096])
{
   if (twiddle_h_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_twiddle_h && !testbench::twiddle_h_ignore)
   {
      int cur_iter = twiddle_h_iteration_count;
      ++twiddle_h_iteration_count;
      mgc_sysc_ver_array1D<ac_int<32, false >,4096> twiddle_h_tmp;
      int twiddle_h_linear_idx = 0;
      for (int twiddle_h_idx_0 = 0; twiddle_h_idx_0 < 4096; ++twiddle_h_idx_0)
         twiddle_h_tmp[twiddle_h_linear_idx++] = twiddle_h[twiddle_h_idx_0];
      ccs_twiddle_h->put(twiddle_h_tmp);
      ++twiddle_h_capture_count;
      mc_testbench_util::process_wait_ctrl("twiddle_h",testbench::twiddle_h_wait_ctrl,ccs_wait_ctrl_twiddle_h.operator->(),cur_iter,twiddle_h_capture_count,0);
   }
   testbench::twiddle_h_ignore = false;
}
// ============================================
// Function: capture_complete
// --------------------------------------------

void mc_testbench::capture_complete( ac_sync &complete)
{
   static mc_golden_info< bool, MaskPacket<1, 1> > complete_tmp(testbench::complete_ignore, false, complete_iteration_count);
   complete_tmp._ignore = testbench::complete_ignore;
   complete_tmp._iteration = complete_iteration_count;
   // BEGIN: testbench output_mask control for field_name complete
   if ( testbench::complete_use_mask ) {
      sc_lv<1> tmp_mask_lv;
      type_to_vector(testbench::complete_output_mask, 1, tmp_mask_lv);
      complete_tmp._use_mask = true;
      complete_tmp._packet._mask = tmp_mask_lv;
   }
   // END: testbench output_mask control for field_name complete
   static int last_j_complete_out = 0;
   if (_capture_complete)
   {
      int cur_iter = complete_capture_count;
      ++complete_iteration_count;
      unsigned int chan_factor = 1;
      unsigned int ccs_scv_i,ccs_scv_j;
      ccs_scv_i = remaining_complete_golden;
      while (ccs_scv_i < complete.ac_channel<bool >::debug_size()) {
         for (ccs_scv_j = last_j_complete_out; ccs_scv_j < chan_factor; ccs_scv_j++,ccs_scv_i++) {
            if (ccs_scv_i < complete.ac_channel<bool >::debug_size()) {
               complete_tmp._data = complete.ac_channel<bool >::chan[ccs_scv_i];
            } else {
               break;
            }
         }
         if (ccs_scv_j == chan_factor) {
            complete_golden.put(complete_tmp);
            last_j_complete_out = 0;
            complete_capture_count += chan_factor;
         } else {
            last_j_complete_out = ccs_scv_j;
         }
      }
      mc_testbench_util::process_wait_ctrl("complete",testbench::complete_wait_ctrl,ccs_wait_ctrl_complete.operator->(),cur_iter,complete_capture_count,1);
      testbench::complete_use_mask = false;
   }
   testbench::complete_ignore = false;
   testbench::complete_skip = false;
}
// ============================================
// Function: wait_on_input_required
// --------------------------------------------

void mc_testbench::wait_on_input_required()
{
   ++wait_cnt;
   wait(SC_ZERO_TIME); // get fifos a chance to update
   ++period_counter;
   sc_time timeout = sc_time_stamp() - previous_timestamp;
   if (calculate_period && sc_time_stamp() > SC_ZERO_TIME && sc_time_stamp() != previous_timestamp && sc_time_stamp() != timeout) {
      average_period = (average_period + timeout) / 2;
   }
   previous_timestamp = sc_time_stamp();
   while (atleast_one_active_input) {
      if (_capture_run && ccs_run->used() == 0) return;
      if (_capture_vec_IN && ccs_vec_IN->used() == 0) return;
      if (_capture_p && ccs_p->used() == 0) return;
      if (_capture_r && ccs_r->used() == 0) return;
      if (_capture_twiddle && ccs_twiddle->used() == 0) return;
      if (_capture_twiddle_h && ccs_twiddle_h->used() == 0) return;
      that->cpp_testbench_active.write(false);
      if (average_period > SC_ZERO_TIME && sc_time_stamp() != timeout)
         wait(average_period * 10, ccs_run->ok_to_put() | ccs_vec_IN->ok_to_put() | ccs_p->ok_to_put() | ccs_r->ok_to_put() | ccs_twiddle->ok_to_put() | ccs_twiddle_h->ok_to_put());
      else
         wait(ccs_run->ok_to_put() | ccs_vec_IN->ok_to_put() | ccs_p->ok_to_put() | ccs_r->ok_to_put() | ccs_twiddle->ok_to_put() | ccs_twiddle_h->ok_to_put());
      that->cpp_testbench_active.write(true);
      if (timed_out()) {
         calculate_period = false;
         return;
      }
   }
}
// ============================================
// Function: capture_IN
// --------------------------------------------

void mc_testbench::capture_IN( ac_sync &run,  ac_int<32, false > vec[4096], ac_int<32, false > p, ac_int<32, false > r,  ac_int<32, false > twiddle[4096],  ac_int<32, false > twiddle_h[4096],  ac_sync &complete)
{
   that->capture_run(run);
   that->capture_vec_IN(vec);
   that->capture_p(p);
   that->capture_r(r);
   that->capture_twiddle(twiddle);
   that->capture_twiddle_h(twiddle_h);
   that->remaining_complete_golden =  complete.ac_channel<bool >::debug_size();
}
// ============================================
// Function: capture_OUT
// --------------------------------------------

void mc_testbench::capture_OUT( ac_sync &run,  ac_int<32, false > vec[4096], ac_int<32, false > p, ac_int<32, false > r,  ac_int<32, false > twiddle[4096],  ac_int<32, false > twiddle_h[4096],  ac_sync &complete)
{
   that->remaining_ccs_run =  run.ac_channel<bool >::debug_size();
   if (testbench::enable_idle_sync_mode && that->remaining_ccs_run != 0) {
      cout << "Warning: Testbench input channel 'run' not empty. Remaining size: " << that->remaining_ccs_run << endl;
   }
   that->capture_vec(vec);
   that->capture_complete(complete);
}
// ============================================
// Function: exec_inPlaceNTT_DIT_precomp
// --------------------------------------------

void mc_testbench::exec_inPlaceNTT_DIT_precomp( ac_sync &run,  ac_int<32, false > vec[4096], ac_int<32, false > p, ac_int<32, false > r,  ac_int<32, false > twiddle[4096],  ac_int<32, false > twiddle_h[4096],  ac_sync &complete)
{
   #ifndef CCS_SCVERIFY_USE_CCS_BLOCK
   that->cpp_testbench_active.write(true);
   capture_IN(run, vec, p, r, twiddle, twiddle_h, complete);
   inPlaceNTT_DIT_precomp(run, vec, p, r, twiddle, twiddle_h, complete);
   // throttle ac_channel based on number of calls to chan::size() or chan::empty() or chan::nb_read() (but not chan::available()) 
   if (1) {
      int cnt=0;
      if (cnt) std::cout << "mc_testbench.cpp: CONTINUES @ " << sc_time_stamp() << std::endl;
      if (cnt) that->cpp_testbench_active.write(true);
   }
   capture_OUT(run, vec, p, r, twiddle, twiddle_h, complete);
   #else
   #endif
}
// ============================================
// Function: start_of_simulation
// --------------------------------------------

void mc_testbench::start_of_simulation()
{
   set_enable_stalls(false);
}
// ============================================
// Function: end_of_simulation
// --------------------------------------------

void mc_testbench::end_of_simulation()
{
   if (!_checked_results) {
      SC_REPORT_INFO(name(), "Testbench exited early or ran into deadlock");
      check_results();
   }
}
// ============================================
// Function: check_results
// --------------------------------------------

void mc_testbench::check_results()
{
   if (_checked_results) return;
   _checked_results = true;
   cout<<endl;
   cout<<"Checking results"<<endl;
   if (main_exit_code) _failed = true;
   int _num_outputs_checked = 0;
   bool _has_capture_counts = false;
   std::ostringstream mctb_msg;
   
   if (!_capture_vec) {
      cout<<"'vec' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= vec_comp->check_results(vec_capture_count,testbench::vec_skip_noerr);
      _has_capture_counts |= !!(vec_capture_count);
   }
   if (!_capture_complete) {
      cout<<"'complete' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= complete_comp->check_results(complete_capture_count,testbench::complete_skip_noerr);
      _has_capture_counts |= !!(complete_capture_count);
   }
   cout<<endl;
   if (_num_outputs_checked == 0) {
      cout<<"Error: All outputs were optimized away. No output values were compared."<<endl;
      _failed = _failed || (_num_outputs_checked == 0);
   }
   if (!_has_capture_counts) {
      cout<<"Error: Nothing to compare, all output capture counts are zero."<<endl;
      _failed = true;
   }
   if (main_exit_code) cout << "Error: C++ Testbench 'main()' returned a non-zero exit code ("<<main_exit_code<<"). Check your testbench." <<endl;
   mctb_msg.clear();
   if (_failed) mctb_msg << "Simulation FAILED";
   else         mctb_msg << "Simulation PASSED";
   mctb_msg << " @ " << sc_time_stamp();
   if (_channel_mismatch && _failed)
   mctb_msg << endl << "An input channel was switched before the input fifo was fully empty. Check your testbench.";
   SC_REPORT_INFO(this->name(), mctb_msg.str().c_str());
}
// ============================================
// Function: failed
// --------------------------------------------

bool mc_testbench::failed()
{
   return _failed;
}
// ============================================
// Function: set_failed
// --------------------------------------------

void mc_testbench::set_failed(bool fail)
{
   _failed = fail;
}
// ---------------------------------------------------------------
// Process: SC_METHOD wait_for_end
// Static sensitivity: sensitive << clk.pos() << testbench_end_event;

void mc_testbench::wait_for_end() {
   // If run() has not finished, we do nothing here
   if (!testbench_ended) return;
   // check for completed outputs
   if (vec_comp->get_compare_count() < vec_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   if (complete_comp->get_compare_count() < complete_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   // If we made it here, all outputs have flushed. Check the results
   SC_REPORT_INFO(name(), "Simulation completed");
   check_results();
   sc_stop();
}
// ---------------------------------------------------------------
// Process: SC_THREAD run
// Static sensitivity: 

void mc_testbench::run() {
   testbench::enable_idle_sync_mode = false;
   testbench::idle_sync_stable_cycles = 1;
   _channel_mismatch = false;
   testbench::run_ignore = false;
   testbench::run_skip = false;
   testbench::run_skip_quiet = false;
   testbench::run_skip_once = false;
   testbench::run_skip_noerr = false;
   testbench::run_array_comp_first = -1;
   testbench::run_array_comp_last = -1;
   testbench::run_wait_ctrl.clear();
   run_capture_count = 0;
   run_iteration_count = 0;
   run_pointer_set = false;
   testbench::vec_ignore = false;
   testbench::vec_skip = false;
   testbench::vec_skip_quiet = false;
   testbench::vec_skip_once = false;
   testbench::vec_skip_noerr = false;
   testbench::vec_array_comp_first = -1;
   testbench::vec_array_comp_last = -1;
   testbench::vec_IN_wait_ctrl.clear();
   vec_IN_capture_count = 0;
   vec_IN_iteration_count = 0;
   testbench::vec_use_mask = false;
   testbench::vec_output_mask = (ac_int<32, false >) ~0;
   testbench::vec_wait_ctrl.clear();
   vec_capture_count = 0;
   vec_iteration_count = 0;
   vec_IN_access_ptr = 0;
   vec_access_ptr = 0;
   testbench::p_ignore = false;
   testbench::p_skip = false;
   testbench::p_skip_quiet = false;
   testbench::p_skip_once = false;
   testbench::p_skip_noerr = false;
   testbench::p_array_comp_first = -1;
   testbench::p_array_comp_last = -1;
   testbench::p_wait_ctrl.clear();
   p_capture_count = 0;
   p_iteration_count = 0;
   testbench::r_ignore = false;
   testbench::r_skip = false;
   testbench::r_skip_quiet = false;
   testbench::r_skip_once = false;
   testbench::r_skip_noerr = false;
   testbench::r_array_comp_first = -1;
   testbench::r_array_comp_last = -1;
   testbench::r_wait_ctrl.clear();
   r_capture_count = 0;
   r_iteration_count = 0;
   testbench::twiddle_ignore = false;
   testbench::twiddle_skip = false;
   testbench::twiddle_skip_quiet = false;
   testbench::twiddle_skip_once = false;
   testbench::twiddle_skip_noerr = false;
   testbench::twiddle_array_comp_first = -1;
   testbench::twiddle_array_comp_last = -1;
   testbench::twiddle_wait_ctrl.clear();
   twiddle_capture_count = 0;
   twiddle_iteration_count = 0;
   twiddle_access_ptr = 0;
   testbench::twiddle_h_ignore = false;
   testbench::twiddle_h_skip = false;
   testbench::twiddle_h_skip_quiet = false;
   testbench::twiddle_h_skip_once = false;
   testbench::twiddle_h_skip_noerr = false;
   testbench::twiddle_h_array_comp_first = -1;
   testbench::twiddle_h_array_comp_last = -1;
   testbench::twiddle_h_wait_ctrl.clear();
   twiddle_h_capture_count = 0;
   twiddle_h_iteration_count = 0;
   twiddle_h_access_ptr = 0;
   testbench::complete_ignore = false;
   testbench::complete_skip = false;
   testbench::complete_skip_quiet = false;
   testbench::complete_skip_once = false;
   testbench::complete_skip_noerr = false;
   testbench::complete_array_comp_first = -1;
   testbench::complete_array_comp_last = -1;
   testbench::complete_use_mask = false;
   testbench::complete_output_mask = (bool) ~0;
   testbench::complete_wait_ctrl.clear();
   complete_capture_count = 0;
   complete_iteration_count = 0;
   complete_pointer_set = false;
   testbench testbench_inst(sc_argc(), sc_argv());
   main_exit_code = testbench_inst.main();
   cout<<"Info: Execution of user-supplied C++ testbench 'main()' has completed with exit code = " << main_exit_code << endl;
   cout<<endl;
   cout<<"Info: Collecting data completed"<<endl;
   cout<<"   captured "<<run_capture_count<<" values of run"<<endl;
   cout<<"   captured "<<vec_IN_capture_count<<" values of vec_IN"<<endl;
   cout<<"   captured "<<vec_capture_count<<" values of vec"<<endl;
   cout<<"   captured "<<p_capture_count<<" values of p"<<endl;
   cout<<"   captured "<<r_capture_count<<" values of r"<<endl;
   cout<<"   captured "<<twiddle_capture_count<<" values of twiddle"<<endl;
   cout<<"   captured "<<twiddle_h_capture_count<<" values of twiddle_h"<<endl;
   cout<<"   captured "<<complete_capture_count<<" values of complete"<<endl;
   testbench_ended = true;
   testbench_end_event.notify(SC_ZERO_TIME);
}
#ifdef CCS_SCVERIFY_USE_CCS_BLOCK
#include "ccs_block_macros.cpp"
#endif
